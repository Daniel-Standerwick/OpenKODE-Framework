/* -----------------------------------------------------------------------------------
 *
 *      File            CCParticleSystem.h
 *      Ported By       Young-Hwan Mun
 *      Contact         xmsoft77@gmail.com 
 * 
 * -----------------------------------------------------------------------------------
 *   
 *      Copyright (c) 2010-2014 XMSoft
 *      Copyright (c) 2010-2013 cocos2d-x.org
 *      Copyright (c) 2008-2010 Ricardo Quesada
 *      Copyright (c) 2011      Zynga Inc.
 *
 *         http://www.cocos2d-x.org      
 *
 * -----------------------------------------------------------------------------------
 * 
 *     Permission is hereby granted, free of charge, to any person obtaining a copy
 *     of this software and associated documentation files (the "Software"), to deal
 *     in the Software without restriction, including without limitation the rights
 *     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *     copies of the Software, and to permit persons to whom the Software is
 *     furnished to do so, subject to the following conditions:
 *
 *     The above copyright notice and this permission notice shall be included in
 *     all copies or substantial portions of the Software.
 *     
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *     THE SOFTWARE.
 *
 * --------------------------------------------------------------------------------- */ 

#ifndef __CCParticleSystem_h__
#define __CCParticleSystem_h__

#include "../base_nodes/CCNode.h"
#include "../../base/CCDictionary.h"
#include "../../base/CCString.h"

NS_CC_BEGIN

/**
 *	@addtogroup particle_nodes
 *	@{
 */

class ParticleBatchNode;

/**
 *	Structure that contains the values of each particle
 */
typedef struct sParticle 
{
    Point				pos;
    Point				startPos;

    Color4F				color;
    Color4F				deltaColor;

    KDfloat				size;
    KDfloat				deltaSize;

    KDfloat				rotation;
    KDfloat				deltaRotation;

    KDfloat				timeToLive;

    KDuint				atlasIndex;

    //! Mode A: gravity, direction, radial accel, tangential accel
    struct 
	{
        Point			dir;
        KDfloat			radialAccel;
        KDfloat			tangentialAccel;
    } modeA;

    //! Mode B: radius mode
    struct 
	{
        KDfloat        angle;
        KDfloat        degreesPerSecond;
        KDfloat        radius;
        KDfloat        deltaRadius;
    } modeB;

}tParticle;

//typedef void (*CC_UPDATE_PARTICLE_IMP)(id, SEL, tParticle*, Point);

class Texture2D;

/**
 *	@brief Particle System base class.
 *	Attributes of a Particle System:
 *		- emission rate of the particles
 *		- Gravity Mode (Mode A):
 *		- gravity
 *		- direction
 *		- speed +-  variance
 *		- tangential acceleration +- variance
 *		- radial acceleration +- variance
 *		- Radius Mode (Mode B):
 *		- startRadius +- variance
 *		- endRadius +- variance
 *		- rotate +- variance
 *		- Properties common to all modes:
 *		- life +- life variance
 *		- start spin +- variance
 *		- end spin +- variance
 *		- start size +- variance
 *		- end size +- variance
 *		- start color +- variance
 *		- end color +- variance
 *		- life +- variance
 *		- blending function
 *		- texture
 *
 *	cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
 *	'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guaranteed in cocos2d,
 *	cocos2d uses a another approach, but the results are almost identical. 
 *
 *	cocos2d supports all the variables used by Particle Designer plus a bit more:
 *		- spinning particles (supported when using ParticleSystemQuad)
 *		- tangential acceleration (Gravity mode)
 *		- radial acceleration (Gravity mode)
 *		- radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)
 *
 *	It is possible to customize any of the above mentioned properties in runtime. Example:
 *
 *	@code
 *	emitter.radialAccel = 15;
 *	emitter.startSpin = 0;
 *	@endcode
 *
 */
class CC_DLL ParticleSystem : public Node, public TextureProtocol
{
	public :

		enum class Mode
		{
			GRAVITY,
			RADIUS,
		};
    
		/** 
		 *	@typedef PositionType
		 *	possible types of particle positions
		 */
		enum class PositionType
		{
			/** Living particles are attached to the world and are unaffected by emitter repositioning. */
			FREE,
        
			/** Living particles are attached to the world but will follow the emitter repositioning.
			 Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite.
			 */
			RELATIVE,
        
			/** Living particles are attached to the emitter and are translated along with it. */
			GROUPED,
		};
    
		//* @enum
		enum 
		{
			/** The Particle emitter lives forever */
			DURATION_INFINITY = -1,
        
			/** The starting size of the particle is equal to the ending size */
			START_SIZE_EQUAL_TO_END_SIZE = -1,
        
			/** The starting radius of the particle is equal to the ending radius */
			START_RADIUS_EQUAL_TO_END_RADIUS = -1,
		};
    
		/** 
		 *	creates an initializes a ParticleSystem from a plist file.
		 *	This plist files can be created manually or with Particle Designer:
		 *	http://particledesigner.71squared.com/
		 *	@since v2.0
		 */
		static ParticleSystem*		create ( const std::string& sPlistFile );

		//! create a system with a fixed number of particles
		static ParticleSystem*		createWithTotalParticles ( KDuint uNumberOfParticles );

		/**
		 *	@js ctor
		 */
		ParticleSystem ( KDvoid );

		/**
		 *	@js NA
		 *	@lua NA
		 */
		virtual ~ParticleSystem ( KDvoid );

		/** initializes a ParticleSystem*/
		KDbool						init ( KDvoid );

		/**
		 *	initializes a ParticleSystem from a plist file.
		 *	This plist files can be created manually or with Particle Designer:
		 *	http://particledesigner.71squared.com/
		 *	@since v0.99.3
		 */
		KDbool						initWithFile ( const std::string& sPlistFile );

		/**
		 *	initializes a QuadParticleSystem from a Dictionary.
		 *	@since v0.99.3
		 */
		KDbool						initWithDictionary ( Dictionary* pDictionary );
    
		/**
		 *	initializes a particle system from a NSDictionary and the path from where to load the png
		 *	@since v2.1
		 */
		KDbool						initWithDictionary ( Dictionary* pDictionary, const std::string& sDirname );

		//! Initializes a system with a fixed number of particles
		virtual KDbool				initWithTotalParticles ( KDuint uNumberOfParticles );

		//! Add a particle to the emitter
		KDbool						addParticle ( KDvoid );
		//! Initializes a particle
		KDvoid						initParticle ( tParticle* pParticle );
		//! stop emitting particles. Running particles will continue to run until they die
		KDvoid						stopSystem ( KDvoid );
		//! Kill all living particles.
		KDvoid						resetSystem ( KDvoid );
		//! whether or not the system is full
		KDbool						isFull ( KDvoid );

		//! should be overridden by subclasses
		virtual KDvoid				updateQuadWithParticle ( tParticle* pParticle, const Point& tNewPosition );
		//! should be overridden by subclasses
		virtual KDvoid				postStep ( KDvoid );

		virtual KDvoid				updateWithNoTime ( KDvoid );

		virtual KDbool				 isAutoRemoveOnFinish ( KDvoid ) const;
		virtual KDvoid				setAutoRemoveOnFinish ( KDbool bVar );

		// mode A
		virtual const Point&		getGravity ( KDvoid );
		virtual KDvoid				setGravity ( const Point& g );

		virtual KDfloat				getSpeed ( KDvoid ) const;
		virtual KDvoid				setSpeed ( KDfloat fSpeed );

		virtual KDfloat				getSpeedVar ( KDvoid ) const;
		virtual KDvoid				setSpeedVar ( KDfloat fSpeed );

		virtual KDfloat				getTangentialAccel ( KDvoid ) const;
		virtual KDvoid				setTangentialAccel ( KDfloat t );

		virtual KDfloat				getTangentialAccelVar ( KDvoid ) const;
		virtual KDvoid				setTangentialAccelVar ( KDfloat t );

		virtual KDfloat				getRadialAccel ( KDvoid ) const;
		virtual KDvoid				setRadialAccel ( KDfloat t );

		virtual KDfloat				getRadialAccelVar ( KDvoid ) const;
		virtual KDvoid				setRadialAccelVar ( KDfloat t );

		virtual KDbool				getRotationIsDir ( KDvoid ) const;
		virtual KDvoid				setRotationIsDir ( KDbool t );

		// mode B
		virtual KDfloat				getStartRadius ( KDvoid ) const;
		virtual KDvoid				setStartRadius ( KDfloat fStartRadius );

		virtual KDfloat				getStartRadiusVar ( KDvoid ) const;
		virtual KDvoid				setStartRadiusVar ( KDfloat fStartRadiusVar );

		virtual KDfloat				getEndRadius ( KDvoid ) const;
		virtual KDvoid				setEndRadius ( KDfloat fEndRadius );

		virtual KDfloat				getEndRadiusVar ( KDvoid ) const;
		virtual KDvoid				setEndRadiusVar ( KDfloat fEndRadiusVar );
		
		virtual KDfloat				getRotatePerSecond ( KDvoid ) const;
		virtual KDvoid				setRotatePerSecond ( KDfloat fDegrees );

		virtual KDfloat				getRotatePerSecondVar ( KDvoid ) const;
		virtual KDvoid				setRotatePerSecondVar ( KDfloat fDegrees );

		virtual KDvoid				setScale ( KDfloat s );
		virtual KDvoid				setRotation ( KDfloat fNewRotation );
		virtual KDvoid				setScaleX ( KDfloat fNewScaleX );
		virtual KDvoid				setScaleY ( KDfloat fNewScaleY );

		virtual KDbool				isActive ( KDvoid ) const;
		virtual KDbool				isBlendAdditive ( KDvoid ) const;
		virtual KDvoid				setBlendAdditive ( KDbool bValue );

		virtual ParticleBatchNode*	getBatchNode ( KDvoid ) const;
		virtual KDvoid				setBatchNode ( ParticleBatchNode* pBatchNode );
    
		// index of system in batch node array
		inline KDint				getAtlasIndex ( KDvoid ) const { return m_nAtlasIndex; }
		inline KDvoid				setAtlasIndex ( KDint nIndex ) { m_nAtlasIndex = nIndex; }

		/** Quantity of particles that are being simulated at the moment */
		inline KDuint				getParticleCount ( KDvoid ) const { return m_nParticleCount; }
    
		/** How many seconds the emitter will run. -1 means 'forever' */
		inline KDfloat				getDuration ( KDvoid ) const { return m_fDuration; }
		inline KDvoid				setDuration ( KDfloat fDuration ) { m_fDuration = fDuration; }
    
		/** sourcePosition of the emitter */
		inline const Point&			getSourcePosition ( KDvoid ) const { return m_tSourcePosition; }
		inline KDvoid				setSourcePosition ( const Point& tPos ) { m_tSourcePosition = tPos; }
    
		/** Position variance of the emitter */
		inline const Point&			getPosVar ( KDvoid ) const { return m_tPosVar; }
		inline KDvoid				setPosVar ( const Point& tPos ) { m_tPosVar = tPos; }

		/** life, and life variation of each particle */
		inline KDfloat				getLife ( KDvoid ) const { return m_fLife; }
		inline KDvoid				setLife ( KDfloat fLife ) { m_fLife = fLife; }

		/** life variance of each particle */
		inline KDfloat				getLifeVar ( KDvoid ) const { return m_fLifeVar; }
		inline KDvoid				setLifeVar ( KDfloat fLifeVar ) { m_fLifeVar = fLifeVar; }

		/** angle and angle variation of each particle */
		inline KDfloat				getAngle ( KDvoid ) const { return m_fAngle; }
		inline KDvoid				setAngle ( KDfloat fAngle ) { m_fAngle = fAngle; }

		/** angle variance of each particle */
		inline KDfloat				getAngleVar ( KDvoid ) const { return m_fAngleVar; }
		inline KDvoid				setAngleVar ( KDfloat fAngleVar ) { m_fAngleVar = fAngleVar; }
    
		/**
		 *	Switch between different kind of emitter modes:
		 *		- kParticleModeGravity: uses gravity, speed, radial and tangential acceleration
		 *		- kParticleModeRadius: uses radius movement + rotation
		 */
		inline Mode					getEmitterMode ( KDvoid ) const { return m_eEmitterMode; }
		inline KDvoid				setEmitterMode ( Mode eMode ) { m_eEmitterMode = eMode; }
    
		/** start size in pixels of each particle */
		inline KDfloat				getStartSize ( KDvoid ) const { return m_fStartSize; }
		inline KDvoid				setStartSize ( KDfloat fStartSize ) { m_fStartSize = fStartSize; }

		/** size variance in pixels of each particle */
		inline KDfloat				getStartSizeVar ( KDvoid ) const { return m_fStartSizeVar; }
		inline KDvoid				setStartSizeVar ( KDfloat fSizeVar ) { m_fStartSizeVar = fSizeVar; }

		/** end size in pixels of each particle */
		inline KDfloat				getEndSize ( KDvoid ) const { return m_fEndSize; }
		inline KDvoid				setEndSize ( KDfloat fEndSize ) { m_fEndSize = fEndSize; }

		/** end size variance in pixels of each particle */
		inline KDfloat				getEndSizeVar ( KDvoid ) const { return m_fEndSizeVar; }
		inline KDvoid				setEndSizeVar ( KDfloat fSizeVar ) { m_fEndSizeVar = fSizeVar; }

		/** start color of each particle */
		inline const Color4F&		getStartColor ( KDvoid ) const { return m_tStartColor; }
		inline KDvoid				setStartColor ( const Color4F& tColor ) { m_tStartColor = tColor; }

		/** start color variance of each particle */
		inline const Color4F&		getStartColorVar ( KDvoid ) const { return m_tStartColorVar; }
		inline KDvoid				setStartColorVar ( const Color4F& tColor ) { m_tStartColorVar = tColor; }

		/** end color and end color variation of each particle */
		inline const Color4F&		getEndColor ( KDvoid ) const { return m_tEndColor; }
		inline KDvoid				setEndColor ( const Color4F& tColor ) { m_tEndColor = tColor; }

		/** end color variance of each particle */
		inline const Color4F&		getEndColorVar ( KDvoid ) const { return m_tEndColorVar; }
		inline KDvoid				setEndColorVar ( const Color4F& tColor ) { m_tEndColorVar = tColor; }

		//* initial angle of each particle
		inline KDfloat				getStartSpin ( KDvoid ) const { return m_fStartSpin; }
		inline KDvoid				setStartSpin ( KDfloat fSpin ) { m_fStartSpin = fSpin; }

		//* initial angle of each particle
		inline KDfloat				getStartSpinVar ( KDvoid ) const { return m_fStartSpinVar; }
		inline KDvoid				setStartSpinVar ( KDfloat fPinVar ) { m_fStartSpinVar = fPinVar; }

		//* initial angle of each particle
		inline KDfloat				getEndSpin ( KDvoid ) const { return m_fEndSpin; }
		inline KDvoid				setEndSpin ( KDfloat fEndSpin ) { m_fEndSpin = fEndSpin; }

		//* initial angle of each particle
		inline KDfloat				getEndSpinVar ( KDvoid ) const { return m_fEndSpinVar; }
		inline KDvoid				setEndSpinVar ( KDfloat fEndSpinVar ) { m_fEndSpinVar = fEndSpinVar; }

		/** emission rate of the particles */
		inline KDfloat				getEmissionRate ( KDvoid ) const { return m_fEmissionRate; }
		inline KDvoid				setEmissionRate ( KDfloat fRate ) { m_fEmissionRate = fRate; }

		/** maximum particles of the system */
		virtual KDint				getTotalParticles ( KDvoid ) const;
		virtual KDvoid				setTotalParticles ( KDint nTotalParticles );

		/** does the alpha value modify color */
		inline KDvoid				setOpacityModifyRGB ( KDbool bOpacityModifyRGB ) { m_bOpacityModifyRGB = bOpacityModifyRGB; }
		inline KDbool				 isOpacityModifyRGB ( KDvoid ) const { return m_bOpacityModifyRGB; }

		/** 
		 *	particles movement type: Free or Grouped
		 *	@since v0.8
		 */
		inline PositionType			getPositionType ( KDvoid ) const { return m_ePositionType; }
		inline KDvoid				setPositionType ( PositionType eType ) { m_ePositionType = eType; }
    
		// Overrides
		virtual KDvoid				update ( KDfloat dt ) override;
		virtual Texture2D*			getTexture ( KDvoid ) const override;
		virtual KDvoid				setTexture ( Texture2D* pTexture ) override;

		/**
		 *	@code
		 *	When this function bound into js or lua,the parameter will be changed
		 *	In js: var setBlendFunc(var src, var dst)
		 *	In lua: local setBlendFunc(local src, local dst)
		 *	@endcode
		 */
		virtual KDvoid				setBlendFunc ( const BlendFunc& tBlendFunc ) override;
		
		/**
		 *	@js NA
		 *	@lua NA
		 */
		virtual const BlendFunc&	getBlendFunc ( KDvoid ) const override;

	protected :

		virtual KDvoid				updateBlendFunc ( KDvoid );

	protected :

		/**
		 *	whether or not the particles are using blend additive.
		 *	If enabled, the following blending function will be used.
		 *	@code
		 *	source blend function = GL_SRC_ALPHA;
		 *	dest blend function = GL_ONE;
		 *	@endcode
		 */
		KDbool						m_bIsBlendAdditive;

		/** 
		 *	whether or not the node will be auto-removed when it has no particles left.
		 *	By default it is false.
		 *	@since v0.8
		 */
		KDbool						m_bIsAutoRemoveOnFinish;

		std::string					m_sPlistFile;
		//! time elapsed since the start of the system (in seconds)
		KDfloat						m_fElapsed;

		// Different modes
		//! Mode A:Gravity + Tangential Accel + Radial Accel
		struct 
		{
			/** Gravity value. Only available in 'Gravity' mode. */
			Point					tGravity;
			/** speed of each particle. Only available in 'Gravity' mode.  */
			KDfloat					fSpeed;
			/** speed variance of each particle. Only available in 'Gravity' mode. */
			KDfloat					fSpeedVar;
			/** tangential acceleration of each particle. Only available in 'Gravity' mode. */
			KDfloat					fTangentialAccel;
			/** tangential acceleration variance of each particle. Only available in 'Gravity' mode. */
			KDfloat					fTangentialAccelVar;
			/** radial acceleration of each particle. Only available in 'Gravity' mode. */
			KDfloat					fRadialAccel;
			/** radial acceleration variance of each particle. Only available in 'Gravity' mode. */
			KDfloat					fRadialAccelVar;
			/** set the rotation of each particle to its direction Only available in 'Gravity' mode. */
			KDbool					bRotationIsDir;
		} m_tModeA;

		//! Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)
		struct 
		{
			/** The starting radius of the particles. Only available in 'Radius' mode. */
			KDfloat					fStartRadius;
			/** The starting radius variance of the particles. Only available in 'Radius' mode. */
			KDfloat					fStartRadiusVar;
			/** The ending radius of the particles. Only available in 'Radius' mode. */
			KDfloat					fEndRadius;
			/** The ending radius variance of the particles. Only available in 'Radius' mode. */
			KDfloat					fEndRadiusVar;
			/** Number of degrees to rotate a particle around the source pos per second. Only available in 'Radius' mode. */
			KDfloat					fRotatePerSecond;
			/** Variance in degrees for rotatePerSecond. Only available in 'Radius' mode. */
			KDfloat					fRotatePerSecondVar;
		} m_tModeB;

		//! Array of particles
		tParticle*					m_pParticles;

		// Emitter name
		std::string					m_sConfigName;

		// color modulate
		//    BOOL colorModulate;

		//! How many particles can be emitted per second
		KDfloat						m_fEmitCounter;

		//!  particle idx
		KDint						m_nParticleIdx;

		// Optimization
		//CC_UPDATE_PARTICLE_IMP    updateParticleImp;
		//SEL                        updateParticleSel;

		/** weak reference to the SpriteBatchNode that renders the Sprite */
		ParticleBatchNode*			m_pBatchNode;

		// index of system in batch node array
		KDint						m_nAtlasIndex;

		//true if scaled or rotated
		KDbool						m_bTransformSystemDirty;
		// Number of allocated particles
		KDint						m_nAllocatedParticles;

		/** Is the emitter active */
		KDbool						m_bIsActive;
    
		/** Quantity of particles that are being simulated at the moment */
		KDint						m_nParticleCount;
		/** How many seconds the emitter will run. -1 means 'forever' */
		KDfloat						m_fDuration;
		/** sourcePosition of the emitter */
		Point						m_tSourcePosition;
		/** Position variance of the emitter */
		Point						m_tPosVar;
		/** life, and life variation of each particle */
		KDfloat						m_fLife;
		/** life variance of each particle */
		KDfloat						m_fLifeVar;
		/** angle and angle variation of each particle */
		KDfloat						m_fAngle;
		/** angle variance of each particle */
		KDfloat						m_fAngleVar;

		/** 
		 *	Switch between different kind of emitter modes:
		 *		- kParticleModeGravity: uses gravity, speed, radial and tangential acceleration
		 *		- kParticleModeRadius: uses radius movement + rotation
		 */
		Mode						m_eEmitterMode;

		/** start size in pixels of each particle */
		KDfloat						m_fStartSize;
		/** size variance in pixels of each particle */
		KDfloat						m_fStartSizeVar;
		/** end size in pixels of each particle */
		KDfloat						m_fEndSize;
		/** end size variance in pixels of each particle */
		KDfloat						m_fEndSizeVar;
		/** start color of each particle */
		Color4F						m_tStartColor;
		/** start color variance of each particle */
		Color4F						m_tStartColorVar;
		/** end color and end color variation of each particle */
		Color4F						m_tEndColor;
		/** end color variance of each particle */
		Color4F						m_tEndColorVar;
		//* initial angle of each particle
		KDfloat						m_fStartSpin;
		//* initial angle of each particle
		KDfloat						m_fStartSpinVar;
		//* initial angle of each particle
		KDfloat						m_fEndSpin;
		//* initial angle of each particle
		KDfloat						m_fEndSpinVar;
		/** emission rate of the particles */
		KDfloat						m_fEmissionRate;
		/** maximum particles of the system */
		KDint						m_nTotalParticles;
		/** conforms to CocosNodeTexture protocol */
		Texture2D*					m_pTexture;
		/** conforms to CocosNodeTexture protocol */
		BlendFunc					m_tBlendFunc;
		/** does the alpha value modify color */
		KDbool						m_bOpacityModifyRGB;
		/** does FlippedY variance of each particle */
		KDint						m_nCoordFlippedY;

		/** 
		 *	particles movement type: Free or Grouped
		 *	@since v0.8
		 */
		PositionType				m_ePositionType;
};

// end of particle_nodes group
/// @}

NS_CC_END

#endif //__CCPARTICLE_SYSTEM_H__
